kernel:
  image: linuxkit/kernel:6.12.59
  cmdline: "console=ttyS0 console=tty0 quiet loglevel=3 net.ifnames=0 biosdevname=0"

init:
  - linuxkit/init:b5506cc74a6812dc40982cacfd2f4328f8a4b12a
  - linuxkit/runc:9442aa234715e751a16144f1d4ae3fd1a00fd492
  - linuxkit/containerd:ba19f64efd3331a8fd0a33e00eabd14f6ee1780e
  - linuxkit/ca-certificates:256f1950df59f2f209e9f0b81374177409eb11de

onboot:
  - name: mount-runner-token
    image: alpine:3.21
    command:
      - /bin/sh
      - -c
      - |
        set -eu
        mkdir -p /runner-token
        for i in $(seq 1 30); do
          if mount -t virtiofs runner-token /runner-token 2>/dev/null; then
            echo "Mounted runner-token virtiofs"
            break
          fi
          echo "Waiting for virtiofs... ($i/30)"
          sleep 1
        done
    capabilities: [CAP_SYS_ADMIN]
    rootfsPropagation: shared
    binds:
      - /runner-token:/runner-token:rshared

  - name: mount-workdir
    image: alpine:3.21
    command:
      - /bin/sh
      - -c
      - |
        set -eu
        for i in $(seq 1 30); do
          if [ -b /dev/vda ]; then
            echo "Found work disk at /dev/vda"
            break
          fi
          echo "Waiting for work disk... ($i/30)"
          sleep 1
        done

        mkfs.ext4 -F -q /dev/vda
        mkdir -p /work
        mount /dev/vda /work

        mkdir -p /work/runner /work/_work /work/_diag /work/tmp /work/docker
        chmod 755 /work/runner /work/_work /work/_diag /work/tmp /work/docker
        echo "Work directory ready at /work"
    capabilities: [CAP_SYS_ADMIN]
    rootfsPropagation: shared
    binds:
      - /dev:/dev
      - /work:/work:rshared

  - name: harden-proc
    image: alpine:3.21
    capabilities: [CAP_SYS_ADMIN]
    binds:
      - /proc:/proc
      - /sys:/sys
    command:
      - /bin/sh
      - -c
      - |
        set -eu
        mount -o remount,hidepid=2 /proc 2>/dev/null || true
        sysctl -w kernel.yama.ptrace_scope=3 2>/dev/null || true
        sysctl -w kernel.kptr_restrict=2 2>/dev/null || true
        echo "proc hardening applied (best-effort)"

  # Networking (egress only; KubeVirt DHCP is typically fast)
  - name: dhcp
    image: linuxkit/dhcpcd:b87e9ececac55a65eaa592f4dd8b4e0c3009afdb
    command: ["/sbin/dhcpcd", "--nobackground", "-f", "/dhcpcd.conf", "-1"]

services:
  - name: dind-runner
    image: docker:29-dind
    capabilities: [all]
    net: host
    pid: host
    rootfsPropagation: shared
    binds:
      - /runner-token:/runner-token:ro
      - /work:/work:rshared
      - /var/run:/var/run:rshared
      - /sys/fs/cgroup:/sys/fs/cgroup:rshared
    env:
      - DOCKER_TLS_CERTDIR=
      - DOCKER_DRIVER=overlay2
    command:
      - /bin/sh
      - -lc
      - |
        set -euo pipefail

        echo "== starting dockerd (host daemon) =="
        dockerd \
          --host=unix:///var/run/docker.sock \
          --data-root=/work/docker \
          --storage-driver=overlay2 \
          --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 \
          >/work/_diag/dockerd.log 2>&1 &

        for i in $(seq 1 180); do
          if docker info >/dev/null 2>&1; then
            echo "Docker daemon ready"
            break
          fi
          sleep 0.25
        done
        docker info >/dev/null 2>&1 || { echo "ERROR: docker did not become ready"; tail -n 200 /work/_diag/dockerd.log || true; exit 1; }

        echo "== validate injected inputs =="
        for f in runner-image jitconfig; do
          if [ ! -f "/runner-token/$f" ]; then
            echo "ERROR: /runner-token/$f missing"
            ls -la /runner-token || true
            exit 1
          fi
        done

        RUNNER_IMAGE="$(tr -d '\r\n' < /runner-token/runner-image)"
        echo "Runner image: ${RUNNER_IMAGE}"

        if [ -f /runner-token/runner-version ]; then
          RUNNER_VERSION="$(tr -d '\r\n' < /runner-token/runner-version)"
          RUNNER_TARBALL_URL="https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz"
          echo "Runner version: ${RUNNER_VERSION} (GH.com releases)"
        elif [ -f /runner-token/runner-tarball-url ]; then
          RUNNER_TARBALL_URL="$(tr -d '\r\n' < /runner-token/runner-tarball-url)"
          echo "Runner tarball URL: injected (not printing)"
        else
          echo "ERROR: need /runner-token/runner-version or /runner-token/runner-tarball-url"
          ls -la /runner-token || true
          exit 1
        fi

        echo "== pull runner image + download runner tarball (parallel) =="
        ( docker pull "${RUNNER_IMAGE}" ) & PULL_PID=$!
        ( wget -qO /work/tmp/runner.tgz "${RUNNER_TARBALL_URL}" ) & DL_PID=$!

        wait $PULL_PID
        wait $DL_PID

        if [ -f /runner-token/runner-sha256 ]; then
          SHA="$(tr -d '\r\n' < /runner-token/runner-sha256)"
          echo "${SHA}  /work/tmp/runner.tgz" | sha256sum -c -
          echo "Runner tarball SHA256 verified"
        fi

        echo "== extract actions runner into /work/runner =="
        rm -rf /work/runner/*
        tar -xzf /work/tmp/runner.tgz -C /work/runner
        rm -f /work/tmp/runner.tgz

        echo "== stage jitconfig (one-time) =="
        umask 077
        cp /runner-token/jitconfig /work/tmp/jitconfig
        chmod 600 /work/tmp/jitconfig

        echo "== start runner container =="
        # Workflows use the VM's dockerd via mounted docker.sock.
        docker run --rm \
          --name github-runner \
          --network host \
          -v /var/run/docker.sock:/var/run/docker.sock \
          -v /work/runner:/opt/actions-runner:rw \
          -v /work/_work:/__w:rw \
          -v /work/_diag:/_diag:rw \
          -v /work/tmp:/tmp/host-tmp:rw \
          --entrypoint /bin/bash \
          "${RUNNER_IMAGE}" -lc '
            set -euo pipefail

            # Create a dedicated daemon user for the runner processes (to enforce runner users)
            if ! id runnerd >/dev/null 2>&1; then
              useradd -m -u 1000 -s /bin/bash runnerd
            fi

            mkdir -p /__w /_diag /opt/actions-runner
            chown -R 1000:1000 /__w /_diag /opt/actions-runner || true

            # Read jitconfig then delete immediately (so it isn't left on disk)
            JITCONFIG_FILE="/tmp/host-tmp/jitconfig"
            [ -f "$JITCONFIG_FILE" ] || { echo "ERROR: jitconfig missing"; exit 1; }
            JITCONFIG="$(cat "$JITCONFIG_FILE")"
            rm -f "$JITCONFIG_FILE" || true

            # Sanity: ensure docker is reachable
            docker info >/dev/null 2>&1 || { echo "ERROR: docker socket not usable"; exit 1; }

            # Start runner as runnerd
            exec su -s /bin/bash runnerd -c "
              set -euo pipefail
              cd /opt/actions-runner
              export RUNNER_WORKDIR=/__w
              ./run.sh --jitconfig \"$JITCONFIG\"
            "
          '

        echo "== cleanup =="
        rm -f /work/tmp/jitconfig || true

        echo "== poweroff =="
        poweroff -f || true
